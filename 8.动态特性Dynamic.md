# 动态特性 Dynamic
本篇记录了动态特性的简介

### 在C#中动态是什么？
`动态(Dynamic)`是`C#4.0`加入的新特性，让C#有时候能具有解释性语言的功能。`C#`本身为编译型语言，即静态语言，同类的还有`Java`。而解释性语言，又即动态语言，属于这种类型的有`Ruby`, `Javascript`, `Python`等等。要理解`C#`中的动态特性，要先明白静态语言和动态语言的区别。这两者的区别在于:

* 静态语言中，对类型、成员、属性、方法的解释发生在编译时。比如当我们用静态语尝试访问并没有被定义的变量成员，那么编译器会告诉我们没有找到该变量
* 动态语言中，对类型、成员、属性、方法的解释发生在运行时。所有变量在定义时都不用声明其类型，类型默认为其赋值的类型
* 静态语言属于强类型定义语言。其安全、严谨，所有非逻辑错误都会在编译时被指出并修正
* 动态语言属于弱类型定义语言。其最大的好处在于编码时方便快捷，不用做类型强制转换，相应的，为了保证代码安全，需要做更多的单元测试

### 为什么要在C#中增加动态特性？
为了增强`C#`与`COM`(即组件对象模型`Component Object Model`,如写office类型的应用)和`动态语言`(如`IronPython`)的交互能力。在很多情况下，我们需要与内容不明的`dll`交互。当我们需要访问、调用或将其中的一些变量赋值的时候，如果没有动态特性，那么就需要用到`反射(Reflection)`来获知其中目标变量的类型。

反射是C#中的一个复杂且略混乱的特性，其为一种通过检视类的`元数据(Metadata)`来获得信息，由此来访问这个类的属性和方法的一种方法。

举一个用反射的例子来说明其复杂性：
```c#
Static void Main(string[] args)
{
  object obj = "Hellow World";
  
  //obj为object的实例，当我们要访问其中的方法的时候，可以直接访问
  var hash = obj.GetHashCode();
  
  //如果使用反射，那么就得这样写
  var methodInfo = obj.GetType().GetMethod("GetHashCode");
  methodInfo.Invoke(null, null);
}
```
以上仅为一个反射例子，这里不作反射的多讨论，未来会专开一篇详解。回到问题，为什么要使用动态特性，避免使用反射？其最核心的原因是反射会降低性能，同时在编译的时候无法保证类型的安全性。

### 动态特性有什么用？如何使用？
当我们给一个变量定义为`动态(dynamic)`后，该变量的类型就是动态型，其具体类型与赋予其值的类型相同，每进行一次赋值其类型都可以被改变而不用强制转换。这点很符合动态语言的特性。要使用`C#`动态特性，使用关键词`dynamic`. 举个具体的例子：
```c#
static void Main(string[] args)
{
  dynamic str = "Hello World";  //在这里str在编译时的类型为dynamic，运行时的类型string
  str = 10;  //这里str在编译时的类型仍然为dynamic，但运行时的类型变为为int
  
  dynamic a = 10;  //编译时为dynamic，运行时为int
  dynamic b = 5;  //编译时为dynamic，运行时为int
  var c = a + b;  //编译时为dynamic，运行时为int
  
  int i = 5;
  dynamic d = i;  //d在编译时为dynamic，运行时为int
  long l = d;  //因为d在运行时为int，int转换为long时不需要进行升降级操作，同理d也不需要
}
```

暂时想到这么多，最后更新2017/11/16

最后更新2018/05/06
